# Input: the cubic threefold X (use homogeneous 5-variable cubic polynomial F below), an odd prime power q
# Output: the number E_c(q)/q

def LazyErrorRatio(c_1,c_2,c_3,c_4,c_5,c_6,q):
    k = GF(q,'a')
    R = PolynomialRing(k, 6, 'x_1,x_2,x_3,x_4,x_5,x_6')
    x_1, x_2, x_3, x_4, x_5, x_6 = R.gens()

    # We are interested in x_1^3+...+x_6^3 = c_1x_1+...+c_6x_6=0.
    # If c_6 != 0, we can do a speedup, reducing to 5 variables using the linear equation.
    if c_6 != 0:
        F_gen = c_6^3*(x_1^3 + x_2^3 + x_3^3 + x_4^3 + x_5^3) - (c_1*x_1 + c_2*x_2 + c_3*x_3 + c_4*x_4 + c_5*x_5)^3;
        gen_lazy_point_count = 0
        P_gen.<t_1,t_2,t_3,t_4,t_5> = ProjectiveSpace(4,k)
        for p in P_gen.rational_points():
            # https://doc.sagemath.org/html/en/reference/schemes/sage/schemes/projective/projective_space.html
            if F_gen(p[0],p[1],p[2],p[3],p[4],0) == 0:
                gen_lazy_point_count += 1;
        E_c = gen_lazy_point_count - (q^3 + q^2 + q + 1)
        return E_c/q

    # In general, we will count points the laziest way possible.
    F = x_1^3 + x_2^3 + x_3^3 + x_4^3 + x_5^3 + x_6^3
    H = c_1*x_1 + c_2*x_2 + c_3*x_3 + c_4*x_4 + c_5*x_5 + c_6*x_6
    lazy_point_count = 0
    P.<t_1,t_2,t_3,t_4,t_5,t_6> = ProjectiveSpace(5,k)
    for p in P.rational_points():
        # https://doc.sagemath.org/html/en/reference/schemes/sage/schemes/projective/projective_space.html
        if F(p[0],p[1],p[2],p[3],p[4],p[5]) == H(p[0],p[1],p[2],p[3],p[4],p[5]) == 0:
            lazy_point_count += 1

    E_c = lazy_point_count - (q^3 + q^2 + q + 1)
    return E_c/q